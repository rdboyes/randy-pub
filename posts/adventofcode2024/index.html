<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
         
        <link rel="stylesheet" href="/libs/highlight/styles/github.min.css">
 
        <link rel="stylesheet" href="/css/reset.css" />
        <link rel="stylesheet" href="/css/normalize.css" />
        <link rel="stylesheet" href="/css/basic.css" />
        <link rel="icon" href="/assets/favicon.png" />
        
        <title>Advent of Code Week 1</title>
        
    </head>
    <body>
        <table class="header">
    <tr>
        <td colspan="2" rowspan="3" scope="header" class="width-min">
            <h1 class="title">randy.pub</h1>
            <span class="subtitle">Personal homepage</span>
        </td>
        <td scope="header" class="width-min">Author</td>
        <td scope="header" class="width-auto">Randy Boyes</td>
    </tr>
    <tr>
        <td scope="header" class="width-min">Updated</td>
        <td scope="header" class="width-auto">
            <time> December 05, 2024</time>
        </td>
    </tr>
    <tr>
        <td scope="header" class="width-min">Nav</td>
        <td scope="header" class="width-auto">
            <a href="/">Home</a>
            <a href="/pubs/">Publications</a>
            <a href="/resume/">Resume</a>
            <a href="/posts/">Posts</a>
        </td>
    </tr>
</table>
<label class="debug-toggle-label"
    ><input type="checkbox" class="debug-toggle" /> Debug mode</label
>


        <!-- Content appended here -->
    </body>
    <div class="debug-grid"></div>
    <script>
        function gridCellDimensions() {
            const element = document.createElement("div");
            element.style.position = "fixed";
            element.style.height = "var(--line-height)";
            element.style.width = "1ch";
            document.body.appendChild(element);
            const rect = element.getBoundingClientRect();
            document.body.removeChild(element);
            return { width: rect.width, height: rect.height };
        }

        // Add padding to each media to maintain grid.
        function adjustMediaPadding() {
            const cell = gridCellDimensions();

            function setHeightFromRatio(media, ratio) {
                const rect = media.getBoundingClientRect();
                const realHeight = rect.width / ratio;
                const diff = cell.height - (realHeight % cell.height);
                media.style.setProperty("padding-bottom", `${diff}px`);
            }

            function setFallbackHeight(media) {
                const rect = media.getBoundingClientRect();
                const height =
                    Math.round(rect.width / 2 / cell.height) * cell.height;
                media.style.setProperty("height", `${height}px`);
            }

            function onMediaLoaded(media) {
                var width, height;
                switch (media.tagName) {
                    case "IMG":
                        width = media.naturalWidth;
                        height = media.naturalHeight;
                        break;
                    case "VIDEO":
                        width = media.videoWidth;
                        height = media.videoHeight;
                        break;
                }
                if (width > 0 && height > 0) {
                    setHeightFromRatio(media, width / height);
                } else {
                    setFallbackHeight(media);
                }
            }

            const medias = document.querySelectorAll("img, video");
            for (media of medias) {
                switch (media.tagName) {
                    case "IMG":
                        if (media.complete) {
                            onMediaLoaded(media);
                        } else {
                            media.addEventListener("load", () =>
                                onMediaLoaded(media),
                            );
                            media.addEventListener("error", function () {
                                setFallbackHeight(media);
                            });
                        }
                        break;
                    case "VIDEO":
                        switch (media.readyState) {
                            case HTMLMediaElement.HAVE_CURRENT_DATA:
                            case HTMLMediaElement.HAVE_FUTURE_DATA:
                            case HTMLMediaElement.HAVE_ENOUGH_DATA:
                                onMediaLoaded(media);
                                break;
                            default:
                                media.addEventListener("loadeddata", () =>
                                    onMediaLoaded(media),
                                );
                                media.addEventListener("error", function () {
                                    setFallbackHeight(media);
                                });
                                break;
                        }
                        break;
                }
            }
        }

        adjustMediaPadding();
        window.addEventListener("load", adjustMediaPadding);
        window.addEventListener("resize", adjustMediaPadding);

        function checkOffsets() {
            const ignoredTagNames = new Set([
                "THEAD",
                "TBODY",
                "TFOOT",
                "TR",
                "TD",
                "TH",
            ]);
            const cell = gridCellDimensions();
            const elements = document.querySelectorAll(
                "body :not(.debug-grid, .debug-toggle)",
            );
            for (const element of elements) {
                if (ignoredTagNames.has(element.tagName)) {
                    continue;
                }
                const rect = element.getBoundingClientRect();
                if (rect.width === 0 && rect.height === 0) {
                    continue;
                }
                const top = rect.top + window.scrollY;
                const left = rect.left + window.scrollX;
                const offset = top % (cell.height / 2);
                if (offset > 0) {
                    element.classList.add("off-grid");
                    console.error(
                        "Incorrect vertical offset for",
                        element,
                        "with remainder",
                        top % cell.height,
                        "when expecting divisible by",
                        cell.height / 2,
                    );
                } else {
                    element.classList.remove("off-grid");
                }
            }
        }

        const debugToggle = document.querySelector(".debug-toggle");
        function onDebugToggle() {
            document.body.classList.toggle("debug", debugToggle.checked);
        }
        debugToggle.addEventListener("change", onDebugToggle);
        onDebugToggle();
    </script>
</html>
<div class="franklin-content"><h2 id="takeaways_from_advent_of_code_week_1"><a href="#takeaways_from_advent_of_code_week_1" class="header-anchor">Takeaways from Advent of Code Week 1</a></h2>
<p>It&#39;s the most wonderful time of year again - time to engage in my time-honored tradition of starting advent of code and losing steam after the first week when it gets hard. As I did last year, I&#39;ll try this in pure Tidier.jl, hoping to find some rough edges that we can smooth out.</p>
<h3 id="day_1"><a href="#day_1" class="header-anchor">Day 1</a></h3>
<p>Unlike last year&#39;s first week, Day 1 is nice and easy.</p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> TidierFiles
<span class="hljs-keyword">using</span> TidierData
<span class="hljs-keyword">using</span> DataFrames

df = read_csv(<span class="hljs-string">&quot;data/1.txt&quot;</span>, col_names = <span class="hljs-literal">false</span>, delim = <span class="hljs-string">&quot;   &quot;</span>)

p1 = <span class="hljs-meta">@chain</span> DataFrame(c1 = sort(df.Column1), c2 = sort(df.Column2)) <span class="hljs-keyword">begin</span>
    <span class="hljs-meta">@mutate</span>(diff = abs(c1 - c2))
    <span class="hljs-meta">@pull</span>(diff)
    sum
<span class="hljs-keyword">end</span>

println(<span class="hljs-string">&quot;Part 1: <span class="hljs-variable">$p1</span>&quot;</span>)

p2 = <span class="hljs-meta">@chain</span> df <span class="hljs-keyword">begin</span>
    <span class="hljs-meta">@aside</span> c1 = <span class="hljs-meta">@count</span>(_, Column1)
    <span class="hljs-meta">@count</span>(Column2)
    <span class="hljs-meta">@rename</span>(n_1 = n)
    <span class="hljs-meta">@left_join</span>(c1, <span class="hljs-string">&quot;Column2&quot;</span> = <span class="hljs-string">&quot;Column1&quot;</span>)
    <span class="hljs-meta">@mutate</span>(sim_score = Column2 * n * n_1)
    <span class="hljs-meta">@filter</span>(!ismissing(sim_score))
    <span class="hljs-meta">@pull</span>(sim_score)
    sum
<span class="hljs-keyword">end</span>

print(<span class="hljs-string">&quot;Part 2: <span class="hljs-variable">$p2</span>&quot;</span>)</code></pre>
<p>Not much to say about Part 1. Independently sorting columns not really a useful operation on a DataFrame usually so the support for it in Tidier is non-existent as far as I can tell, and I think that&#39;s a good thing.</p>
<p>Part 2 has more rough edges:</p>
<ul>
<li><p>There seems to be no way to name the column that contains @count&#39;s counts, which means I have to rely on a extra line&#39;d @rename &#40;ew&#41; or type out the equivalent @summarize call &#40;even worse?&#41; - looking it up, this is how it works in R&#39;s tidyverse as well. Fair enough, I guess, but I want a .col_name argument anyway.</p>
</li>
<li><p>There&#39;s no way to pass arguments through to DataFrames.leftjoin directly, so we can&#39;t solve the rename problem with makeunique, either. This one seems like an actual improvement to add rather than a pointless nitpick like the first point.</p>
</li>
<li><p>The required syntax for non-matching column joins doesn&#39;t match R&#39;s left_join OR the DataFrames.leftjoin syntax. This seems unintuitive. Scared to check the git blame and find out it was me who implemented this...</p>
</li>
</ul>
<p>On the plus side, I love the @aside macro more every time I use it and wish it existed in R as well.</p>
<h3 id="day_2"><a href="#day_2" class="header-anchor">Day 2</a></h3>
<p>Does it still count as &quot;pure Tidier.jl&quot; if you write functions outside of the chain? I&#39;m going with yes.</p>
<pre><code class="julia hljs">df = read_csv(<span class="hljs-string">&quot;data/2.txt&quot;</span>, col_names = <span class="hljs-literal">false</span>)

to_int(x) = parse.(<span class="hljs-built_in">Int</span>, x)
check_safe(steps) = all(steps .&gt; <span class="hljs-number">0</span> .&amp;&amp; steps .&lt;  <span class="hljs-number">4</span>) ||
                    all(steps .&lt; <span class="hljs-number">0</span> .&amp;&amp; steps .&gt; -<span class="hljs-number">4</span>)

p1 = <span class="hljs-meta">@chain</span> df <span class="hljs-keyword">begin</span>
    <span class="hljs-meta">@transmute</span>(list = to_int(split(Column1)))
    <span class="hljs-meta">@mutate</span>(steps = diff(list))
    <span class="hljs-meta">@mutate</span>(safe = check_safe(steps))
    <span class="hljs-meta">@pull</span>(safe)
    sum
<span class="hljs-keyword">end</span>

println(<span class="hljs-string">&quot;Part 1: <span class="hljs-variable">$p1</span>&quot;</span>)

check_all(l) = check_safe.(diff.([l[<span class="hljs-number">1</span>:<span class="hljs-keyword">end</span> .!= i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:length(l)]))

p2 = <span class="hljs-meta">@chain</span> df <span class="hljs-keyword">begin</span>
    <span class="hljs-meta">@transmute</span>(list = to_int(split(Column1)))
    <span class="hljs-meta">@mutate</span>(safe = any(check_all(list)))
    <span class="hljs-meta">@pull</span>(safe)
    sum
<span class="hljs-keyword">end</span>

println(<span class="hljs-string">&quot;Part 2: <span class="hljs-variable">$p2</span>&quot;</span>)</code></pre>
<p>One of the biggest struggles here was trying to get fine control of the exact vectorization of functions across list-columns with the Tidier toolbox. You can turn on and off vectorization, sure, but to write a solution to this problem I needed to vectorize <em>inside rows</em> and I don&#39;t know if that functionality exists or is fully developed. Using list comprehesion inside macros also doesn&#39;t seem possible, since you get errors related to the variable &quot;i&quot; and &quot;end&quot; if you try to use the &quot;check_all&quot; function inside a mutate.</p>
<h3 id="day_3"><a href="#day_3" class="header-anchor">Day 3</a></h3>
<p>The first regex problem of many&#33;</p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> TidierStrings
<span class="hljs-keyword">using</span> TidierData

<span class="hljs-keyword">function</span> str_extract_all_cap(string::<span class="hljs-built_in">AbstractString</span>, pattern::<span class="hljs-built_in">Union</span>{<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Regex</span>}; captures::<span class="hljs-built_in">Bool</span>=<span class="hljs-literal">false</span>)
    regex_pattern = <span class="hljs-keyword">isa</span>(pattern, <span class="hljs-built_in">String</span>) ? <span class="hljs-built_in">Regex</span>(pattern) : pattern
    to_missing(l) = [ifelse(isnothing(c), <span class="hljs-literal">missing</span>, c) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> l]
    matches = captures ?
        [to_missing(m.captures) <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> eachmatch(regex_pattern, string)] :
        [<span class="hljs-built_in">String</span>(m.match) <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> eachmatch(regex_pattern, string)]
    <span class="hljs-keyword">return</span> isempty(matches) ? <span class="hljs-literal">missing</span> : matches
<span class="hljs-keyword">end</span>

p1 = <span class="hljs-meta">@chain</span> *(readlines(<span class="hljs-string">&quot;data/3.txt&quot;</span>)...) <span class="hljs-keyword">begin</span>
    str_extract_all_cap(<span class="hljs-string">r&quot;mul\((?&lt;n1&gt;\d+),(?&lt;n2&gt;\d+)\)&quot;</span>, captures = <span class="hljs-literal">true</span>)
    map(x -&gt; prod(parse.(<span class="hljs-built_in">Int</span>, x)), _)
    sum
<span class="hljs-keyword">end</span>

println(<span class="hljs-string">&quot;Part 1: <span class="hljs-variable">$p1</span>&quot;</span>)

p2 = <span class="hljs-meta">@chain</span> *(readlines(<span class="hljs-string">&quot;data/3.txt&quot;</span>)...) <span class="hljs-keyword">begin</span>
    str_extract_all_cap(<span class="hljs-string">r&quot;mul\((\d+),(\d+)\)|(do(?:n&#x27;t)?\(\))&quot;</span>, captures = <span class="hljs-literal">true</span>)
    DataFrame(mapreduce(permutedims, vcat, _), :auto)
    <span class="hljs-meta">@fill_missing</span>(x3, <span class="hljs-string">&quot;down&quot;</span>)
    <span class="hljs-meta">@mutate</span>(x3 = replace_missing(x3, <span class="hljs-string">&quot;do()&quot;</span>))
    <span class="hljs-meta">@filter</span>(x3 != <span class="hljs-string">&quot;don&#x27;t()&quot;</span>)
    <span class="hljs-meta">@mutate</span>(prod = as_integer(x1) * as_integer(x2))
    <span class="hljs-meta">@filter</span>(!ismissing(prod))
    <span class="hljs-meta">@pull</span>(prod)
    sum
<span class="hljs-keyword">end</span>

println(<span class="hljs-string">&quot;Part 2: <span class="hljs-variable">$p2</span>&quot;</span>)</code></pre>
<p>TidierStrings.str&#95;extract&#95;all doesn&#39;t &#40;currently&#33; PR submitted&#41; support capture groups so I wrote a version that does. Otherwise this is kind of a &quot;classic&quot; AoC regex problem, nothing too difficult. Something tells me Day 4 is going to be difficult...</p>
<h3 id="day_4"><a href="#day_4" class="header-anchor">Day 4</a></h3>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> TidierStrings

text = readlines(<span class="hljs-string">&quot;data/4.txt&quot;</span>)
nl = length(text)
ts = split.(text, <span class="hljs-string">&quot;&quot;</span>)

fb = text

ud = reduce(*, reduce(hcat, ts), dims = <span class="hljs-number">2</span>)

diag1 = [
    [ts[x][y] <span class="hljs-keyword">for</span> (x, y) <span class="hljs-keyword">in</span>
    Iterators.product(<span class="hljs-number">1</span>:nl, <span class="hljs-number">1</span>:nl) <span class="hljs-keyword">if</span> x + y == z]
    <span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> <span class="hljs-number">2</span>:(nl*<span class="hljs-number">2</span>)
]

diag2 = [
    [ts[x][y] <span class="hljs-keyword">for</span> (x, y) <span class="hljs-keyword">in</span>
    Iterators.product(<span class="hljs-number">1</span>:nl, <span class="hljs-number">1</span>:nl) <span class="hljs-keyword">if</span> x - y == z]
    <span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> (nl-<span class="hljs-number">1</span>):-<span class="hljs-number">1</span>:(-(nl-<span class="hljs-number">1</span>))
]

<span class="hljs-keyword">function</span> str_count_overlap(column, pattern::<span class="hljs-built_in">Union</span>{<span class="hljs-built_in">String</span>,<span class="hljs-built_in">Regex</span>}; overlap::<span class="hljs-built_in">Bool</span>=<span class="hljs-literal">false</span>)
    <span class="hljs-keyword">if</span> ismissing(column)
        <span class="hljs-keyword">return</span> (column)
    <span class="hljs-keyword">end</span>

    <span class="hljs-keyword">if</span> pattern <span class="hljs-keyword">isa</span> <span class="hljs-built_in">String</span>
        pattern = <span class="hljs-built_in">Regex</span>(pattern) <span class="hljs-comment"># treat pattern as regular expression</span>
    <span class="hljs-keyword">end</span>

    <span class="hljs-comment"># Count the number of matches for the regular expression</span>
    <span class="hljs-keyword">return</span> length(collect(eachmatch(pattern, column, overlap = overlap)))
<span class="hljs-keyword">end</span>

p1 = sum(vcat(
    str_count_overlap.(text, <span class="hljs-string">&quot;XMAS|SAMX&quot;</span>, overlap=<span class="hljs-literal">true</span>),
    str_count_overlap.(ud, <span class="hljs-string">&quot;XMAS|SAMX&quot;</span>, overlap=<span class="hljs-literal">true</span>),
    str_count_overlap.(map(x -&gt; *(x...), diag1), <span class="hljs-string">&quot;XMAS|SAMX&quot;</span>, overlap=<span class="hljs-literal">true</span>),
    str_count_overlap.(map(x -&gt; *(x...), diag2), <span class="hljs-string">&quot;XMAS|SAMX&quot;</span>, overlap=<span class="hljs-literal">true</span>)
))

println(<span class="hljs-string">&quot;Part 1: <span class="hljs-variable">$p1</span>&quot;</span>)

mat = reduce(hcat, ts)

<span class="hljs-keyword">function</span> is_x_mas(g)
    g[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] != <span class="hljs-string">&quot;A&quot;</span> &amp;&amp; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    sum([g[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], g[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>], g[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], g[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]] .== <span class="hljs-string">&quot;S&quot;</span>) != <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    sum([g[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], g[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>], g[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], g[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]] .== <span class="hljs-string">&quot;M&quot;</span>) != <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    (g[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] == g[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>] || g[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] == g[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]) &amp;&amp; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
<span class="hljs-keyword">end</span>

p2 = sum([is_x_mas(mat[((cx-<span class="hljs-number">1</span>):(cx+<span class="hljs-number">1</span>), (cy-<span class="hljs-number">1</span>):(cy+<span class="hljs-number">1</span>))...]) <span class="hljs-keyword">for</span>
    (cx, cy) <span class="hljs-keyword">in</span> Iterators.product(<span class="hljs-number">2</span>:(nl-<span class="hljs-number">1</span>),<span class="hljs-number">2</span>:(nl-<span class="hljs-number">1</span>))])

println(<span class="hljs-string">&quot;Part 2: <span class="hljs-variable">$p2</span>&quot;</span>)</code></pre>
<p>Another AoC classic, a &quot;grid problem&quot;, and another improvement for TidierStrings to submit as a PR&#33; Julia&#39;s eachmatch function allows for overlaps, no reason not to allow the overlap Bool to pass through from str_count.</p>
<h3 id="day_5"><a href="#day_5" class="header-anchor">Day 5</a></h3>
<p>One of those days where you hit Part 2 and just think ... not today. Happy enough with my part one, although it is very light on the Tidier.jl. <em>&#40;edit: saw a hint about custom sort functions on BlueSky and finished it off&#41;</em></p>
<pre><code class="julia hljs">data = readlines(<span class="hljs-string">&quot;data/5.txt&quot;</span>)
div = findall(data .== <span class="hljs-string">&quot;&quot;</span>)[<span class="hljs-number">1</span>]

to_int(x) = parse.(<span class="hljs-built_in">Int</span>, x)
rules = to_int.(split.(data[<span class="hljs-number">1</span>:(div-<span class="hljs-number">1</span>)], <span class="hljs-string">&quot;|&quot;</span>))
pages = to_int.(split.(data[(div+<span class="hljs-number">1</span>):<span class="hljs-keyword">end</span>], <span class="hljs-string">&quot;,&quot;</span>))

check_rules(p, rl) = ifelse(
    any([r ⊆ p &amp;&amp; !all(p ∩ r .== r) <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> rl]),
    <span class="hljs-number">0</span>, p[ceil(<span class="hljs-built_in">Int</span>, <span class="hljs-keyword">end</span> / <span class="hljs-number">2</span>)])

p1 = sum(check_rules.(pages, (rules,)))

println(<span class="hljs-string">&quot;Part 1: <span class="hljs-variable">$p1</span>&quot;</span>)

rulesort(x, y) = [x, y] <span class="hljs-keyword">in</span> rules
p2 = sum(check_rules.(sort.(pages, lt=rulesort), (rules,))) - p1

println(<span class="hljs-string">&quot;Part 1: <span class="hljs-variable">$p2</span>&quot;</span>)</code></pre>

        <script src="../bsky-comments.js"></script>
        <bsky-comments post="at://did:plc:2h5e6whhbk5vnnerqqoi256k/app.bsky.feed.post/3lcbbseb55c27"></bsky-comments>
    
<div class="page-foot">
    <a href="https://opensource.org/license/mit">MIT License</a> Randy Boyes.  Website built with
    <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the
    <a href="https://julialang.org">Julia programming language</a>. Design
    inspired by
    <a href="https://owickstrom.github.io/the-monospace-web/"
        >The Monospace Web</a
    >. Code for this website is available on
    <a href="https://github.com/rdboyes/randy-pub">Github</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>
    hljs.highlightAll();
    hljs.configure({ tabReplace: "    " });
</script>

    
  </body>
</html>
