<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
         
        <link rel="stylesheet" href="/libs/highlight/styles/github.min.css">
 
        <link rel="stylesheet" href="/css/reset.css" />
        <link rel="stylesheet" href="/css/normalize.css" />
        <link rel="stylesheet" href="/css/basic.css" />
        <link rel="icon" href="/assets/favicon.png" />
        
        <title>Advent of Code Week 2</title>
        
    </head>
    <body>
        <table class="header">
    <tr>
        <td colspan="2" rowspan="3" scope="header" class="width-min">
            <h1 class="title">randy.pub</h1>
            <span class="subtitle">Personal homepage</span>
        </td>
        <td scope="header" class="width-min">Author</td>
        <td scope="header" class="width-auto">Randy Boyes</td>
    </tr>
    <tr>
        <td scope="header" class="width-min">Updated</td>
        <td scope="header" class="width-auto">
            <time> June 17, 2025</time>
        </td>
    </tr>
    <tr>
        <td scope="header" class="width-min">Nav</td>
        <td scope="header" class="width-auto">
            <a href="/">Home</a>
            <a href="/pubs/">Publications</a>
            <a href="/resume/">Resume</a>
            <a href="/posts/">Posts</a>
        </td>
    </tr>
</table>
<label class="debug-toggle-label"
    ><input type="checkbox" class="debug-toggle" /> Debug mode</label
>


        <!-- Content appended here -->
    </body>
    <div class="debug-grid"></div>
    <script>
        function gridCellDimensions() {
            const element = document.createElement("div");
            element.style.position = "fixed";
            element.style.height = "var(--line-height)";
            element.style.width = "1ch";
            document.body.appendChild(element);
            const rect = element.getBoundingClientRect();
            document.body.removeChild(element);
            return { width: rect.width, height: rect.height };
        }

        // Add padding to each media to maintain grid.
        function adjustMediaPadding() {
            const cell = gridCellDimensions();

            function setHeightFromRatio(media, ratio) {
                const rect = media.getBoundingClientRect();
                const realHeight = rect.width / ratio;
                const diff = cell.height - (realHeight % cell.height);
                media.style.setProperty("padding-bottom", `${diff}px`);
            }

            function setFallbackHeight(media) {
                const rect = media.getBoundingClientRect();
                const height =
                    Math.round(rect.width / 2 / cell.height) * cell.height;
                media.style.setProperty("height", `${height}px`);
            }

            function onMediaLoaded(media) {
                var width, height;
                switch (media.tagName) {
                    case "IMG":
                        width = media.naturalWidth;
                        height = media.naturalHeight;
                        break;
                    case "VIDEO":
                        width = media.videoWidth;
                        height = media.videoHeight;
                        break;
                }
                if (width > 0 && height > 0) {
                    setHeightFromRatio(media, width / height);
                } else {
                    setFallbackHeight(media);
                }
            }

            const medias = document.querySelectorAll("img, video");
            for (media of medias) {
                switch (media.tagName) {
                    case "IMG":
                        if (media.complete) {
                            onMediaLoaded(media);
                        } else {
                            media.addEventListener("load", () =>
                                onMediaLoaded(media),
                            );
                            media.addEventListener("error", function () {
                                setFallbackHeight(media);
                            });
                        }
                        break;
                    case "VIDEO":
                        switch (media.readyState) {
                            case HTMLMediaElement.HAVE_CURRENT_DATA:
                            case HTMLMediaElement.HAVE_FUTURE_DATA:
                            case HTMLMediaElement.HAVE_ENOUGH_DATA:
                                onMediaLoaded(media);
                                break;
                            default:
                                media.addEventListener("loadeddata", () =>
                                    onMediaLoaded(media),
                                );
                                media.addEventListener("error", function () {
                                    setFallbackHeight(media);
                                });
                                break;
                        }
                        break;
                }
            }
        }

        adjustMediaPadding();
        window.addEventListener("load", adjustMediaPadding);
        window.addEventListener("resize", adjustMediaPadding);

        function checkOffsets() {
            const ignoredTagNames = new Set([
                "THEAD",
                "TBODY",
                "TFOOT",
                "TR",
                "TD",
                "TH",
            ]);
            const cell = gridCellDimensions();
            const elements = document.querySelectorAll(
                "body :not(.debug-grid, .debug-toggle)",
            );
            for (const element of elements) {
                if (ignoredTagNames.has(element.tagName)) {
                    continue;
                }
                const rect = element.getBoundingClientRect();
                if (rect.width === 0 && rect.height === 0) {
                    continue;
                }
                const top = rect.top + window.scrollY;
                const left = rect.left + window.scrollX;
                const offset = top % (cell.height / 2);
                if (offset > 0) {
                    element.classList.add("off-grid");
                    console.error(
                        "Incorrect vertical offset for",
                        element,
                        "with remainder",
                        top % cell.height,
                        "when expecting divisible by",
                        cell.height / 2,
                    );
                } else {
                    element.classList.remove("off-grid");
                }
            }
        }

        const debugToggle = document.querySelector(".debug-toggle");
        function onDebugToggle() {
            document.body.classList.toggle("debug", debugToggle.checked);
        }
        debugToggle.addEventListener("change", onDebugToggle);
        onDebugToggle();
    </script>
</html>
<div class="franklin-content"><h2 id="takeaways_from_advent_of_code_week_2"><a href="#takeaways_from_advent_of_code_week_2" class="header-anchor">Takeaways from Advent of Code Week 2</a></h2>
<p>To my surprise, I haven&#39;t fallen off the advent of code train yet this year. Full solutions and takeaways for week 1 in julia are in the previous post <a href="https://www.randy.pub/posts/adventofcode2024/">here</a>. I haven&#39;t done the best job of using Tidier packages like I wanted, but for some AoC problems it just feels like a bad fit.</p>
<h3 id="day_8"><a href="#day_8" class="header-anchor">Day 8</a></h3>
<p>First time using CartesianIndex somehow, so useful&#33; I made the choice early to iterate through the potential nodes rather than through the pairs of antennas, I think it was correct but the antenna pairs might be faster since there&#39;s no more than 4 of each type in the file. I was originally thinking I wouldn&#39;t have to recheck nodes that were &quot;on the path&quot; but quickly realized that that would miss a lot of nodes since multiple paths intersect.</p>
<pre><code class="julia hljs">data = permutedims(reduce(hcat, split.(readlines(<span class="hljs-string">&quot;data/8.txt&quot;</span>), <span class="hljs-string">&quot;&quot;</span>)))
side_length = size(data)[<span class="hljs-number">1</span>]
antennas = findall(x -&gt; x != <span class="hljs-string">&quot;.&quot;</span>, data)
nodesp1 = <span class="hljs-built_in">Set</span>{<span class="hljs-built_in">CartesianIndex</span>}()
nodesp2 = <span class="hljs-built_in">Set</span>{<span class="hljs-built_in">CartesianIndex</span>}()

in_bounds(x) = all([i &gt; <span class="hljs-number">0</span> &amp;&amp; i &lt;= side_length <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">Tuple</span>(x)])
gcd_dir(x) = <span class="hljs-built_in">CartesianIndex</span>(x[<span class="hljs-number">1</span>] ÷ gcd(<span class="hljs-built_in">Tuple</span>(x)...), x[<span class="hljs-number">2</span>] ÷ gcd(<span class="hljs-built_in">Tuple</span>(x)...))

<span class="hljs-keyword">for</span> loc <span class="hljs-keyword">in</span> <span class="hljs-built_in">CartesianIndices</span>(data)
    <span class="hljs-keyword">for</span> antenna <span class="hljs-keyword">in</span> filter(x -&gt; x != loc, antennas)
        res_antenna = loc + <span class="hljs-number">2</span> * (antenna - loc)
        <span class="hljs-keyword">if</span> in_bounds(res_antenna) &amp;&amp; data[res_antenna] == data[antenna]
            push!(nodesp1, loc)
            dir = gcd_dir(res_antenna - loc)

            cursor1 = loc + dir
            cursor2 = loc - dir

            <span class="hljs-keyword">while</span> in_bounds(cursor1)
                push!(nodesp2, cursor1)
                cursor1 = cursor1 + dir
            <span class="hljs-keyword">end</span>

            <span class="hljs-keyword">while</span> in_bounds(cursor2)
                push!(nodesp2, cursor2)
                cursor2 = cursor2 - dir
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

println(<span class="hljs-string">&quot;Part 1: <span class="hljs-subst">$(length(nodesp1)</span>)&quot;</span>)
println(<span class="hljs-string">&quot;Part 2: <span class="hljs-subst">$(length(union(nodesp1, nodesp2, antennas)</span>))&quot;</span>)</code></pre>
<h3 id="day_9"><a href="#day_9" class="header-anchor">Day 9</a></h3>
<p>Still struggling with Part 2 on this one.</p>
<pre><code class="julia hljs">to_int(x) = parse.(<span class="hljs-built_in">Int</span>, x)
d = to_int(split.(readline(<span class="hljs-string">&quot;data/9test1.txt&quot;</span>), <span class="hljs-string">&quot;&quot;</span>))

<span class="hljs-keyword">function</span> solve(d)
    c1 = <span class="hljs-number">1</span>
    c2 = length(d)
    total = <span class="hljs-number">0</span>
    count = <span class="hljs-number">0</span>

    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>
        <span class="hljs-keyword">if</span> c1 % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>
            <span class="hljs-keyword">if</span> d[c2] &lt;= d[c1]
                d[c1] -= d[c2]
                new_count = count + d[c2]
                total += (c2 ÷ <span class="hljs-number">2</span>) * sum(count:(new_count-<span class="hljs-number">1</span>))
                <span class="hljs-keyword">if</span> d[c1] == <span class="hljs-number">0</span>
                    c1 += <span class="hljs-number">1</span>
                <span class="hljs-keyword">end</span>
                c2 -= <span class="hljs-number">2</span>
                count = new_count
            <span class="hljs-keyword">else</span>
                d[c2] -= d[c1]
                new_count = count + d[c1]
                total += (c2 ÷ <span class="hljs-number">2</span>) * sum(count:(new_count-<span class="hljs-number">1</span>))
                c1 += <span class="hljs-number">1</span>
                count = new_count
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">else</span>
            new_count = count + d[c1]
            total += (c1 ÷ <span class="hljs-number">2</span>) * sum(count:(new_count-<span class="hljs-number">1</span>))
            count = new_count
            c1 += <span class="hljs-number">1</span>
        <span class="hljs-keyword">end</span>
        c1 &gt; c2 &amp;&amp; <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">end</span>

    <span class="hljs-keyword">return</span> total
<span class="hljs-keyword">end</span>

println(solve(d))</code></pre>
<h3 id="day_10"><a href="#day_10" class="header-anchor">Day 10</a></h3>
<p>First graph problem&#33; I found julia&#39;s Graphs.jl package to be much smoother to work with than R&#39;s igraph, once I understood what it wanted. Most of the code is setup, once the graph is created the solution is easy.</p>
<pre><code class="julia hljs">to_int(x) = parse.(<span class="hljs-built_in">Int8</span>, x)

data = permutedims(
    reduce(hcat, to_int.(split.(readlines(<span class="hljs-string">&quot;data/10.txt&quot;</span>), <span class="hljs-string">&quot;&quot;</span>)))
)

side_length = size(data)[<span class="hljs-number">1</span>]

in_bounds(x) = all([i &gt; <span class="hljs-number">0</span> &amp;&amp; i &lt;= side_length <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">Tuple</span>(x)])

neighbor_dirs = [
    <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>),
    <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>),
    <span class="hljs-built_in">CartesianIndex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),
    <span class="hljs-built_in">CartesianIndex</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
]

<span class="hljs-keyword">using</span> Graphs

c2i = <span class="hljs-built_in">Dict</span>(c =&gt; i <span class="hljs-keyword">for</span> (c, i) <span class="hljs-keyword">in</span> zip(<span class="hljs-built_in">CartesianIndices</span>(data), eachindex(data)))

g = DiGraph()

add_vertices!(g, side_length^<span class="hljs-number">2</span>)

<span class="hljs-keyword">for</span> point <span class="hljs-keyword">in</span> <span class="hljs-built_in">CartesianIndices</span>(data)
    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> neighbor_dirs
        <span class="hljs-keyword">if</span> in_bounds(n + point)
            <span class="hljs-keyword">if</span> data[n + point] == data[point] + <span class="hljs-number">1</span>
                add_edge!(g, c2i[point], c2i[n+point])
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

pathsp1 = <span class="hljs-built_in">Bool</span>[]
pathsp2 = <span class="hljs-built_in">Int</span>[]

<span class="hljs-keyword">for</span> (v0, v9) <span class="hljs-keyword">in</span> Iterators.product(
    [c2i[c] <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> (findall(x -&gt; x == <span class="hljs-number">0</span>, data))],
    [c2i[c] <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> (findall(x -&gt; x == <span class="hljs-number">9</span>, data))])

    push!(pathsp1, has_path(g, v0, v9))
    push!(pathsp2, length(collect(all_simple_paths(g, v0, v9))))
<span class="hljs-keyword">end</span>

println(sum(pathsp1))
print(sum(pathsp2))</code></pre>
<h2 id="day_11"><a href="#day_11" class="header-anchor">Day 11</a></h2>
<p>Ended up using two completely different approaches for parts 1 and 2. The memoized recursion approach here works really quickly for part 1, but self-destructs when you try it for part 2. The dict-based approach is slower but still finishes p2 in 8 milliseconds so who&#39;s complaining...</p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> Memoization

initial = [<span class="hljs-number">64599</span>, <span class="hljs-number">31</span>, <span class="hljs-number">674832</span>, <span class="hljs-number">2659361</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8867</span>, <span class="hljs-number">321</span>]

<span class="hljs-meta">@memoize</span> <span class="hljs-keyword">function</span> split_once(n)
    n == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>]
    dn = digits(n)
    ln = length(dn)
    <span class="hljs-keyword">if</span> isodd(ln)
        <span class="hljs-keyword">return</span> [<span class="hljs-number">2024</span>n]
    <span class="hljs-keyword">else</span>
        n1 = floor(<span class="hljs-built_in">Int</span>, n / (<span class="hljs-number">10</span>^(ln ÷ <span class="hljs-number">2</span>)))
        n2 = n - n1 * <span class="hljs-number">10</span>^(ln ÷ <span class="hljs-number">2</span>)
        <span class="hljs-keyword">return</span> [n1, n2]
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-meta">@memoize</span> <span class="hljs-keyword">function</span> split(n, iter)
    <span class="hljs-keyword">if</span> iter == <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> split_once(n)
    <span class="hljs-keyword">else</span>
        return_value = <span class="hljs-built_in">Int</span>[]
        <span class="hljs-keyword">for</span> ni <span class="hljs-keyword">in</span> split_once(n)
            append!(return_value, split(ni, iter - <span class="hljs-number">1</span>))
        <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">return</span> return_value
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-meta">@btime</span> sum(length.(split.(initial, <span class="hljs-number">25</span>)))

<span class="hljs-keyword">function</span> split_dict_once(stone_dict)
    new_dict = <span class="hljs-built_in">Dict</span>{<span class="hljs-built_in">Int</span>,<span class="hljs-built_in">Int</span>}()
    <span class="hljs-keyword">for</span> (k, v) <span class="hljs-keyword">in</span> stone_dict
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> split_once(k)
            current = get(new_dict, r, <span class="hljs-number">0</span>)
            new_dict[r] = current + v
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> new_dict
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> solvep2(initial, iter)
    initial_dict = <span class="hljs-built_in">Dict</span>(v =&gt; <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> initial)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:iter
        initial_dict = split_dict_once(initial_dict)
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> sum(values(initial_dict))
<span class="hljs-keyword">end</span>

solvep2(initial, <span class="hljs-number">75</span>)</code></pre>
<h2 id="day_13"><a href="#day_13" class="header-anchor">Day 13</a></h2>
<p>Pretty clean solution for Day 13. Don&#39;t love the round/isinteger solution but floating point problems were causing headaches.</p>
<pre><code class="julia hljs">inst = readlines(<span class="hljs-string">&quot;data/13.txt&quot;</span>)

A = [parse.(<span class="hljs-built_in">Int</span>, m.captures) <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span>
     match.(<span class="hljs-string">r&quot;A: X\+(\d+), Y\+(\d+)&quot;</span>, inst) <span class="hljs-keyword">if</span> !isnothing(m)]
B = [parse.(<span class="hljs-built_in">Int</span>, m.captures) <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span>
     match.(<span class="hljs-string">r&quot;B: X\+(\d+), Y\+(\d+)&quot;</span>, inst) <span class="hljs-keyword">if</span> !isnothing(m)]
P = [parse.(<span class="hljs-built_in">Int</span>, m.captures) <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span>
     match.(<span class="hljs-string">r&quot;Prize: X\=(\d+), Y\=(\d+)&quot;</span>, inst) <span class="hljs-keyword">if</span> !isnothing(m)]

<span class="hljs-keyword">function</span> solve(adjust=<span class="hljs-number">0</span>)
    ans = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> eachindex(A)
        sol = hcat(A[i], B[i]) \ (P[i] .+ adjust)
        <span class="hljs-keyword">if</span> all(isinteger.(round.(sol, digits=<span class="hljs-number">3</span>)))
            ans += sum((<span class="hljs-number">3</span>, <span class="hljs-number">1</span>) .* sol)
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> ans
<span class="hljs-keyword">end</span>

println(solve())
println(solve(<span class="hljs-number">10000000000000</span>))</code></pre>
<h2 id="day_14"><a href="#day_14" class="header-anchor">Day 14</a></h2>
<p>Solution to part one runs fast, clean solution. Part two requires you to watch a nearly 17 minute long video generated by Makie.jl to find the tree. I&#39;m sure there was a smart way to do this, but when in doubt, look at the data...</p>
<pre><code class="julia hljs"><span class="hljs-keyword">struct</span> Robot
    initial::<span class="hljs-built_in">CartesianIndex</span>
    velocity::<span class="hljs-built_in">CartesianIndex</span>
<span class="hljs-keyword">end</span>

to_ints(x) = [parse.(<span class="hljs-built_in">Int</span>, m.match) <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> eachmatch(<span class="hljs-string">r&quot;-*\d+&quot;</span>, x)]

robots = [
    Robot(<span class="hljs-built_in">CartesianIndex</span>(x[<span class="hljs-number">1</span>],x[<span class="hljs-number">2</span>]), <span class="hljs-built_in">CartesianIndex</span>(x[<span class="hljs-number">3</span>],x[<span class="hljs-number">4</span>]))
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [to_ints(l) <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> readlines(<span class="hljs-string">&quot;data/14.txt&quot;</span>)]
]

<span class="hljs-keyword">function</span> move(r::Robot, steps::<span class="hljs-built_in">Int</span>, grid::<span class="hljs-built_in">Tuple</span>)
    <span class="hljs-keyword">return</span> mod.(<span class="hljs-built_in">Tuple</span>(r.initial + steps * r.velocity), grid)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> which_quad(position, grid)
    <span class="hljs-keyword">return</span> position[<span class="hljs-number">1</span>] &lt; grid[<span class="hljs-number">1</span>] ÷ <span class="hljs-number">2</span> &amp;&amp; position[<span class="hljs-number">2</span>] &lt; grid[<span class="hljs-number">2</span>] ÷ <span class="hljs-number">2</span> ? <span class="hljs-number">1</span> :
           position[<span class="hljs-number">1</span>] &gt; grid[<span class="hljs-number">1</span>] ÷ <span class="hljs-number">2</span> &amp;&amp; position[<span class="hljs-number">2</span>] &lt; grid[<span class="hljs-number">2</span>] ÷ <span class="hljs-number">2</span> ? <span class="hljs-number">2</span> :
           position[<span class="hljs-number">1</span>] &lt; grid[<span class="hljs-number">1</span>] ÷ <span class="hljs-number">2</span> &amp;&amp; position[<span class="hljs-number">2</span>] &gt; grid[<span class="hljs-number">2</span>] ÷ <span class="hljs-number">2</span> ? <span class="hljs-number">3</span> :
           position[<span class="hljs-number">1</span>] &gt; grid[<span class="hljs-number">1</span>] ÷ <span class="hljs-number">2</span> &amp;&amp; position[<span class="hljs-number">2</span>] &gt; grid[<span class="hljs-number">2</span>] ÷ <span class="hljs-number">2</span> ? <span class="hljs-number">4</span> : <span class="hljs-number">0</span>
<span class="hljs-keyword">end</span>

q = which_quad.(move.(robots, <span class="hljs-built_in">Ref</span>(<span class="hljs-number">100</span>), <span class="hljs-built_in">Ref</span>((<span class="hljs-number">101</span>, <span class="hljs-number">103</span>))), <span class="hljs-built_in">Ref</span>((<span class="hljs-number">101</span>, <span class="hljs-number">103</span>)))
p1 = prod([n[<span class="hljs-number">2</span>] <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> [(i, count(==(i), q)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> unique(q) <span class="hljs-keyword">if</span> i != <span class="hljs-number">0</span>]])

println(p1)

<span class="hljs-keyword">using</span> GLMakie

point_locs(x) = Point2f.(move.(robots, <span class="hljs-built_in">Ref</span>(x), <span class="hljs-built_in">Ref</span>((<span class="hljs-number">101</span>, <span class="hljs-number">103</span>))))
points = Observable(point_locs(<span class="hljs-number">0</span>))

fig, ax = scatter(points)
limits!(ax, <span class="hljs-number">0</span>, <span class="hljs-number">101</span>, <span class="hljs-number">0</span>, <span class="hljs-number">103</span>)

frames = <span class="hljs-number">1</span>:<span class="hljs-number">2000</span>

record(fig, <span class="hljs-string">&quot;tree_animation.mp4&quot;</span>, frames; framerate = <span class="hljs-number">10</span>) <span class="hljs-keyword">do</span> frame
    points[] = point_locs(frame)
    ax.title = string(frame)
<span class="hljs-keyword">end</span></code></pre>
<div class="page-foot">
    <a href="https://opensource.org/license/mit">MIT License</a> Randy Boyes.  Website built with
    <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the
    <a href="https://julialang.org">Julia programming language</a>. Design
    inspired by
    <a href="https://owickstrom.github.io/the-monospace-web/"
        >The Monospace Web</a
    >. Code for this website is available on
    <a href="https://github.com/rdboyes/randy-pub">Github</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>
    hljs.highlightAll();
    hljs.configure({ tabReplace: "    " });
</script>

    
  </body>
</html>
