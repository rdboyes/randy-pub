<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
         
        <link rel="stylesheet" href="/libs/highlight/styles/github.min.css">
 
        <link rel="stylesheet" href="/css/reset.css" />
        <link rel="stylesheet" href="/css/normalize.css" />
        <link rel="stylesheet" href="/css/basic.css" />
        <link rel="icon" href="/assets/favicon.png" />
        
        <title>You wouldn't pirate a type</title>
        
    </head>
    <body>
        <table class="header">
    <tr>
        <td colspan="2" rowspan="3" scope="header" class="width-min">
            <h1 class="title">randy.pub</h1>
            <span class="subtitle">Personal homepage</span>
        </td>
        <td scope="header" class="width-min">Author</td>
        <td scope="header" class="width-auto">Randy Boyes</td>
    </tr>
    <tr>
        <td scope="header" class="width-min">Updated</td>
        <td scope="header" class="width-auto">
            <time> October 29, 2025</time>
        </td>
    </tr>
    <tr>
        <td scope="header" class="width-min">Nav</td>
        <td scope="header" class="width-auto">
            <a href="/">Home</a>
            <a href="/pubs/">Publications</a>
            <a href="/resume/">Resume</a>
            <a href="/posts/">Posts</a>
        </td>
    </tr>
</table>
<label class="debug-toggle-label"
    ><input type="checkbox" class="debug-toggle" /> Debug mode</label
>


        <!-- Content appended here -->
    </body>
    <div class="debug-grid"></div>
    <script>
        function gridCellDimensions() {
            const element = document.createElement("div");
            element.style.position = "fixed";
            element.style.height = "var(--line-height)";
            element.style.width = "1ch";
            document.body.appendChild(element);
            const rect = element.getBoundingClientRect();
            document.body.removeChild(element);
            return { width: rect.width, height: rect.height };
        }

        // Add padding to each media to maintain grid.
        function adjustMediaPadding() {
            const cell = gridCellDimensions();

            function setHeightFromRatio(media, ratio) {
                const rect = media.getBoundingClientRect();
                const realHeight = rect.width / ratio;
                const diff = cell.height - (realHeight % cell.height);
                media.style.setProperty("padding-bottom", `${diff}px`);
            }

            function setFallbackHeight(media) {
                const rect = media.getBoundingClientRect();
                const height =
                    Math.round(rect.width / 2 / cell.height) * cell.height;
                media.style.setProperty("height", `${height}px`);
            }

            function onMediaLoaded(media) {
                var width, height;
                switch (media.tagName) {
                    case "IMG":
                        width = media.naturalWidth;
                        height = media.naturalHeight;
                        break;
                    case "VIDEO":
                        width = media.videoWidth;
                        height = media.videoHeight;
                        break;
                }
                if (width > 0 && height > 0) {
                    setHeightFromRatio(media, width / height);
                } else {
                    setFallbackHeight(media);
                }
            }

            const medias = document.querySelectorAll("img, video");
            for (media of medias) {
                switch (media.tagName) {
                    case "IMG":
                        if (media.complete) {
                            onMediaLoaded(media);
                        } else {
                            media.addEventListener("load", () =>
                                onMediaLoaded(media),
                            );
                            media.addEventListener("error", function () {
                                setFallbackHeight(media);
                            });
                        }
                        break;
                    case "VIDEO":
                        switch (media.readyState) {
                            case HTMLMediaElement.HAVE_CURRENT_DATA:
                            case HTMLMediaElement.HAVE_FUTURE_DATA:
                            case HTMLMediaElement.HAVE_ENOUGH_DATA:
                                onMediaLoaded(media);
                                break;
                            default:
                                media.addEventListener("loadeddata", () =>
                                    onMediaLoaded(media),
                                );
                                media.addEventListener("error", function () {
                                    setFallbackHeight(media);
                                });
                                break;
                        }
                        break;
                }
            }
        }

        adjustMediaPadding();
        window.addEventListener("load", adjustMediaPadding);
        window.addEventListener("resize", adjustMediaPadding);

        function checkOffsets() {
            const ignoredTagNames = new Set([
                "THEAD",
                "TBODY",
                "TFOOT",
                "TR",
                "TD",
                "TH",
            ]);
            const cell = gridCellDimensions();
            const elements = document.querySelectorAll(
                "body :not(.debug-grid, .debug-toggle)",
            );
            for (const element of elements) {
                if (ignoredTagNames.has(element.tagName)) {
                    continue;
                }
                const rect = element.getBoundingClientRect();
                if (rect.width === 0 && rect.height === 0) {
                    continue;
                }
                const top = rect.top + window.scrollY;
                const left = rect.left + window.scrollX;
                const offset = top % (cell.height / 2);
                if (offset > 0) {
                    element.classList.add("off-grid");
                    console.error(
                        "Incorrect vertical offset for",
                        element,
                        "with remainder",
                        top % cell.height,
                        "when expecting divisible by",
                        cell.height / 2,
                    );
                } else {
                    element.classList.remove("off-grid");
                }
            }
        }

        const debugToggle = document.querySelector(".debug-toggle");
        function onDebugToggle() {
            document.body.classList.toggle("debug", debugToggle.checked);
        }
        debugToggle.addEventListener("change", onDebugToggle);
        onDebugToggle();
    </script>
</html>
<div class="franklin-content"><hr />
<h2 id="type_piracy"><a href="#type_piracy" class="header-anchor">Type Piracy</a></h2>
<p>If you aren&#39;t familiar, &quot;type piracy&quot; is when you define versions of methods/functions you don&#39;t own for types you don&#39;t own. The julia community is very anti-type-piracy. Unfortunately for them, piracy is cool. I don&#39;t make the rules.</p>
<p>Why would we want to pirate types? For me, it&#39;s because macros are icky. If I can write a version of code that doesn&#39;t use a macro that works, I prefer it. For example, julia has a native pipe operator &#40;|&gt;&#41;, but it is almost unusable &#40;aesthetically&#41; by default, requiring ugly anonymous functions if the output of one function doesn&#39;t match the input of the next function exactly:</p>
<pre><code class="julia hljs">df |&gt; x -&gt; transform(x, ...) <span class="hljs-comment"># code to specify changes goes in ...</span></code></pre>
<p>So people tend to use macros to implement r-style &quot;pipe chains&quot;:</p>
<pre><code class="julia hljs"><span class="hljs-meta">@chain</span> df <span class="hljs-keyword">begin</span>
    transform(...)
<span class="hljs-keyword">end</span></code></pre>
<p>So many characters. Unnatural <code>@</code> symbols infecting my clean code. I want to write:</p>
<pre><code class="julia hljs">df |&gt; transform(...)</code></pre>
<p>And I will stop at nothing to do it.</p>
<h2 id="start_with_slice"><a href="#start_with_slice" class="header-anchor">Start with <code>slice</code></a></h2>
<p>Starting simple, <code>slice</code> is a <code>dplyr</code> function that selects rows out of a DataFrame based on a given index. Lets make a new Type that wraps function so that we can redefine some behaviour. I&#39;ll call this <code>TidyExpr</code>:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">struct</span> TidyExpr
    f::<span class="hljs-built_in">Function</span>
<span class="hljs-keyword">end</span></code></pre>
<p>Define a function called <code>slice</code> that returns a <code>TidyExpr</code>:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> slice(args...)
    <span class="hljs-keyword">return</span> TidyExpr(x -&gt; x[args[<span class="hljs-number">1</span>], :])
<span class="hljs-keyword">end</span></code></pre>
<p>And redefine what it means to pipe stuff if a <code>TidyExpr</code> is involved.</p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> DataFrames
<span class="hljs-keyword">import</span> Base.|&gt;

Base.:(|&gt;)(x::TidyExpr, y::TidyExpr) = TidyExpr(x.f ∘ y.f)
Base.:(|&gt;)(x::DataFrames.DataFrame, y::TidyExpr) = y.f(x)</code></pre>
<p>This is enough for a basic <code>slice</code> function to work, and we haven&#39;t really committed any crimes &#40;yet&#41;&#33;</p>
<pre><code class="julia hljs">DataFrame(a = <span class="hljs-number">1</span>:<span class="hljs-number">10</span>) |&gt; slice(<span class="hljs-number">3</span>:<span class="hljs-number">7</span>) |&gt; slice(<span class="hljs-number">2</span>:<span class="hljs-number">3</span>)</code></pre>
<pre><code class="plaintext hljs">2×1 DataFrame
 Row │ a
     │ Int64
─────┼───────
   1 │     4
   2 │     5</code></pre>
<h2 id="lets_try_select"><a href="#lets_try_select" class="header-anchor">Lets try <code>select</code></a></h2>
<p>Select picks columns to keep.</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> select(args...)
    <span class="hljs-keyword">return</span> TidyExpr(df -&gt; df[:, [a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> args]])
<span class="hljs-keyword">end</span></code></pre>
<p>Now we can include basic <code>select</code> commands in a hybrid pipeline:</p>
<pre><code class="julia hljs">DataFrame(a = <span class="hljs-number">1</span>:<span class="hljs-number">10</span>, b = <span class="hljs-number">2</span>:<span class="hljs-number">11</span>, c = <span class="hljs-number">3</span>:<span class="hljs-number">12</span>) |&gt; slice(<span class="hljs-number">3</span>:<span class="hljs-number">5</span>) |&gt; select(:a, :b)</code></pre>
<pre><code class="plaintext hljs">3×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     3      4
   2 │     4      5
   3 │     5      6</code></pre>
<p>Here is a good place to note that my attempt to do this without macros is not <em>entirely</em> an aesthetics-driven personal vendetta. We gain a couple of nice abilities for free using this approach - automatic function pipelines and easy &quot;variable interpolation&quot;:</p>
<pre><code class="julia hljs">vars = [:b, :c]
my_pipeline = slice(<span class="hljs-number">3</span>:<span class="hljs-number">5</span>) |&gt; select(vars...)

DataFrame(a = <span class="hljs-number">1</span>:<span class="hljs-number">10</span>, b = <span class="hljs-number">2</span>:<span class="hljs-number">11</span>, c = <span class="hljs-number">3</span>:<span class="hljs-number">12</span>) |&gt; my_pipeline</code></pre>
<pre><code class="plaintext hljs">3×2 DataFrame
 Row │ b      c
     │ Int64  Int64
─────┼──────────────
   1 │     4      5
   2 │     5      6
   3 │     6      7</code></pre>
<h2 id="oh_no_now_its_time_for_filter"><a href="#oh_no_now_its_time_for_filter" class="header-anchor">Oh no, now it&#39;s time for <code>filter</code></a></h2>
<p>The dplyr function <code>filter</code> is like slice in that it selects and retains a subset of rows, except you are supposed to pass it a condition rather than an index. The issue is that we ideally &#40;if we want to have tidyverse-like behaviour&#41; want to pass only a condition, like <code>filter&#40;:b &gt; 3&#41;</code>.</p>
<pre><code class="julia hljs"><span class="hljs-keyword">struct</span> TidyCondition
    x::<span class="hljs-built_in">Any</span>
    y::<span class="hljs-built_in">Any</span>
    op::<span class="hljs-built_in">Function</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">import</span> Base.isless
Base.isless(x::<span class="hljs-built_in">Symbol</span>, y::<span class="hljs-built_in">Any</span>) = TidyCondition(x, y, &lt;)
Base.isless(x::<span class="hljs-built_in">Any</span>, y::<span class="hljs-built_in">Symbol</span>) = TidyCondition(x, y, &lt;)
Base.isless(x::<span class="hljs-built_in">Symbol</span>, y::<span class="hljs-built_in">Symbol</span>) = TidyCondition(x, y, &lt;)

<span class="hljs-keyword">function</span> filter(tc::TidyCondition)
    <span class="hljs-keyword">if</span> tc.x <span class="hljs-keyword">isa</span> <span class="hljs-built_in">Symbol</span>
        <span class="hljs-keyword">if</span> tc.y <span class="hljs-keyword">isa</span> <span class="hljs-built_in">Symbol</span>
            <span class="hljs-keyword">return</span> TidyExpr(df -&gt;
                DataFrames.filter([tc.x, tc.y] =&gt; (x, y) -&gt; tc.op.(x, y), df)
            )
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> TidyExpr(df -&gt;
                DataFrames.filter([tc.x] =&gt; (x) -&gt; tc.op.(x, tc.y), df)
            )
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">elseif</span> tc.y <span class="hljs-keyword">isa</span> <span class="hljs-built_in">Symbol</span>
        <span class="hljs-keyword">return</span> TidyExpr(df -&gt;
            DataFrames.filter([tc.y] =&gt; y -&gt; tc.op.(tc.x, y), df)
        )
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre>
<pre><code class="julia hljs">DataFrame(a = <span class="hljs-number">1</span>:<span class="hljs-number">10</span>, b = <span class="hljs-number">2</span>:<span class="hljs-number">11</span>, c = <span class="hljs-number">3</span>:<span class="hljs-number">12</span>) |&gt; filter(:b &gt; <span class="hljs-number">5</span>)</code></pre>
<pre><code class="plaintext hljs">6×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     5      6      7
   2 │     6      7      8
   3 │     7      8      9
   4 │     8      9     10
   5 │     9     10     11
   6 │    10     11     12</code></pre>
<pre><code class="julia hljs">DataFrame(
    a = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>],
    b = <span class="hljs-number">2</span>:<span class="hljs-number">11</span>,
    c = <span class="hljs-number">3</span>:<span class="hljs-number">12</span>
  ) |&gt; filter(:b &lt; :a)</code></pre>
<pre><code class="plaintext hljs">2×3 DataFrame
 Row │ a      b      c
     │ Int64  Int64  Int64
─────┼─────────────────────
   1 │     3      2      3
   2 │     4      3      4</code></pre>
<p><img src="https://www.enworld.org/media/sickos-gif.167921/full" alt="" /></p>
<h2 id="i_will_not_be_stopped_what_about_mutate"><a href="#i_will_not_be_stopped_what_about_mutate" class="header-anchor">I will not be stopped &#40;what about <code>mutate</code>&#41;</a></h2>
<p>Ok here&#39;s where it <em>really</em> starts going off the rails. <code>mutate</code> accepts functions, which it applies to columns.</p>
<pre><code class="julia hljs"><span class="hljs-keyword">struct</span> TidyMutation
    f::<span class="hljs-built_in">Function</span>
    args::<span class="hljs-built_in">Vector</span>{<span class="hljs-built_in">Any</span>}
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> mutate(args...; kwargs...)
    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> kwargs
        symlist = <span class="hljs-built_in">Symbol</span>[]
        <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> m[<span class="hljs-number">2</span>].args
            <span class="hljs-keyword">if</span> arg <span class="hljs-keyword">isa</span> <span class="hljs-built_in">Symbol</span> <span class="hljs-comment"># i.e., a column reference</span>
                push!(symlist, arg)
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">if</span> length(symlist) == <span class="hljs-number">1</span>
            <span class="hljs-keyword">return</span> TidyExpr(
                df -&gt; transform(df,
                    symlist[<span class="hljs-number">1</span>] =&gt; (x -&gt; m[<span class="hljs-number">2</span>].f(x)) =&gt; [<span class="hljs-built_in">Symbol</span>(m[<span class="hljs-number">1</span>])]
                )
            )
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

Base.:(|&gt;)(x::<span class="hljs-built_in">Symbol</span>, y::<span class="hljs-built_in">Function</span>) = TidyMutation(y, [x])</code></pre>
<p>Now we can use the pipe inside of mutate to apply functions:</p>
<pre><code class="julia hljs">plus_one(x) = x .+ <span class="hljs-number">1</span>
DataFrame(a = <span class="hljs-number">1</span>:<span class="hljs-number">10</span>) |&gt; mutate(b = :a |&gt; plus_one)</code></pre>
<pre><code class="plaintext hljs">10×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      2
   2 │     2      3
   3 │     3      4
   4 │     4      5
   5 │     5      6
   6 │     6      7
   7 │     7      8
   8 │     8      9
   9 │     9     10
  10 │    10     11</code></pre>
<p>Or override the unused <code>getindex</code> of a function to use a square-bracket function call:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">import</span> Base.getindex
Base.getindex(f::<span class="hljs-built_in">Function</span>, args...) = TidyMutation(f, [a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> args])

plus_one(x) = x .+ <span class="hljs-number">1</span>
DataFrame(a = <span class="hljs-number">1</span>:<span class="hljs-number">10</span>) |&gt; mutate(b = plus_one[:a])</code></pre>
<pre><code class="plaintext hljs">10×2 DataFrame
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     1      2
   2 │     2      3
   3 │     3      4
   4 │     4      5
   5 │     5      6
   6 │     6      7
   7 │     7      8
   8 │     8      9
   9 │     9     10
  10 │    10     11</code></pre>
<h2 id="is_this_a_good_idea"><a href="#is_this_a_good_idea" class="header-anchor">Is this a good idea?</a></h2>
<p>No</p>

        <script src="../bsky-comments.js"></script>
        <bsky-comments post="at://did:plc:2h5e6whhbk5vnnerqqoi256k/app.bsky.feed.post/3m2zkdcuf4k26"></bsky-comments>
    
<hr />
<div class="page-foot">
    <a href="https://opensource.org/license/mit">MIT License</a> Randy Boyes.  Website built with
    <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the
    <a href="https://julialang.org">Julia programming language</a>. Design
    inspired by
    <a href="https://owickstrom.github.io/the-monospace-web/"
        >The Monospace Web</a
    >. Code for this website is available on
    <a href="https://github.com/rdboyes/randy-pub">Github</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>
    hljs.highlightAll();
    hljs.configure({ tabReplace: "    " });
</script>

    
  </body>
</html>
