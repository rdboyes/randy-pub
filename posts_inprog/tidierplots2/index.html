<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
         
        <link rel="stylesheet" href="/libs/highlight/styles/github.min.css">
 
        <link rel="stylesheet" href="/css/reset.css" />
        <link rel="stylesheet" href="/css/normalize.css" />
        <link rel="stylesheet" href="/css/basic.css" />
        <link rel="icon" href="/assets/favicon.png" />
        
        <title>Developing TidierPlots.jl, Part 2</title>
        
    </head>
    <body>
        <table class="header">
    <tr>
        <td colspan="2" rowspan="3" scope="header" class="width-min">
            <h1 class="title">randy.pub</h1>
            <span class="subtitle">Personal homepage</span>
        </td>
        <td scope="header" class="width-min">Author</td>
        <td scope="header" class="width-auto">Randy Boyes</td>
    </tr>
    <tr>
        <td scope="header" class="width-min">Updated</td>
        <td scope="header" class="width-auto">
            <time> December 06, 2024</time>
        </td>
    </tr>
    <tr>
        <td scope="header" class="width-min">Nav</td>
        <td scope="header" class="width-auto">
            <a href="/">Home</a>
            <a href="/pubs/">Publications</a>
            <a href="/resume/">Resume</a>
            <a href="/posts/">Posts</a>
        </td>
    </tr>
</table>
<label class="debug-toggle-label"
    ><input type="checkbox" class="debug-toggle" /> Debug mode</label
>


        <!-- Content appended here -->
    </body>
    <div class="debug-grid"></div>
    <script>
        function gridCellDimensions() {
            const element = document.createElement("div");
            element.style.position = "fixed";
            element.style.height = "var(--line-height)";
            element.style.width = "1ch";
            document.body.appendChild(element);
            const rect = element.getBoundingClientRect();
            document.body.removeChild(element);
            return { width: rect.width, height: rect.height };
        }

        // Add padding to each media to maintain grid.
        function adjustMediaPadding() {
            const cell = gridCellDimensions();

            function setHeightFromRatio(media, ratio) {
                const rect = media.getBoundingClientRect();
                const realHeight = rect.width / ratio;
                const diff = cell.height - (realHeight % cell.height);
                media.style.setProperty("padding-bottom", `${diff}px`);
            }

            function setFallbackHeight(media) {
                const rect = media.getBoundingClientRect();
                const height =
                    Math.round(rect.width / 2 / cell.height) * cell.height;
                media.style.setProperty("height", `${height}px`);
            }

            function onMediaLoaded(media) {
                var width, height;
                switch (media.tagName) {
                    case "IMG":
                        width = media.naturalWidth;
                        height = media.naturalHeight;
                        break;
                    case "VIDEO":
                        width = media.videoWidth;
                        height = media.videoHeight;
                        break;
                }
                if (width > 0 && height > 0) {
                    setHeightFromRatio(media, width / height);
                } else {
                    setFallbackHeight(media);
                }
            }

            const medias = document.querySelectorAll("img, video");
            for (media of medias) {
                switch (media.tagName) {
                    case "IMG":
                        if (media.complete) {
                            onMediaLoaded(media);
                        } else {
                            media.addEventListener("load", () =>
                                onMediaLoaded(media),
                            );
                            media.addEventListener("error", function () {
                                setFallbackHeight(media);
                            });
                        }
                        break;
                    case "VIDEO":
                        switch (media.readyState) {
                            case HTMLMediaElement.HAVE_CURRENT_DATA:
                            case HTMLMediaElement.HAVE_FUTURE_DATA:
                            case HTMLMediaElement.HAVE_ENOUGH_DATA:
                                onMediaLoaded(media);
                                break;
                            default:
                                media.addEventListener("loadeddata", () =>
                                    onMediaLoaded(media),
                                );
                                media.addEventListener("error", function () {
                                    setFallbackHeight(media);
                                });
                                break;
                        }
                        break;
                }
            }
        }

        adjustMediaPadding();
        window.addEventListener("load", adjustMediaPadding);
        window.addEventListener("resize", adjustMediaPadding);

        function checkOffsets() {
            const ignoredTagNames = new Set([
                "THEAD",
                "TBODY",
                "TFOOT",
                "TR",
                "TD",
                "TH",
            ]);
            const cell = gridCellDimensions();
            const elements = document.querySelectorAll(
                "body :not(.debug-grid, .debug-toggle)",
            );
            for (const element of elements) {
                if (ignoredTagNames.has(element.tagName)) {
                    continue;
                }
                const rect = element.getBoundingClientRect();
                if (rect.width === 0 && rect.height === 0) {
                    continue;
                }
                const top = rect.top + window.scrollY;
                const left = rect.left + window.scrollX;
                const offset = top % (cell.height / 2);
                if (offset > 0) {
                    element.classList.add("off-grid");
                    console.error(
                        "Incorrect vertical offset for",
                        element,
                        "with remainder",
                        top % cell.height,
                        "when expecting divisible by",
                        cell.height / 2,
                    );
                } else {
                    element.classList.remove("off-grid");
                }
            }
        }

        const debugToggle = document.querySelector(".debug-toggle");
        function onDebugToggle() {
            document.body.classList.toggle("debug", debugToggle.checked);
        }
        debugToggle.addEventListener("change", onDebugToggle);
        onDebugToggle();
    </script>
</html>
<div class="franklin-content"><hr />
<h1 id="in_progress"><a href="#in_progress" class="header-anchor">In Progress</a></h1>
<h2 id="quick_wins"><a href="#quick_wins" class="header-anchor">Quick Wins</a></h2>
<p>The early development on TidierPlots felt seamless. R&#39;s ggplot has a behaviour where plots will show automatically when you create them, and I was able to replicate that experience with a call to <code>display</code> when the <code>&#43;</code> operation was used to construct a ggplot object:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> Base.:+(x::ggplot, y...)::ggplot
    result = ggplot(vcat(x.geoms, [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> y]),
        x.default_aes,
        x.data,
        x.axis)

    <span class="hljs-comment"># don&#x27;t tell the julia police</span>
    <span class="hljs-keyword">if</span> autoplot
        display(draw_ggplot(result))
    <span class="hljs-keyword">end</span>

    <span class="hljs-keyword">return</span> result
<span class="hljs-keyword">end</span></code></pre>
<p>I also quickly added support for <code>geoms</code> that lined up nicely with AlgebraOfGraphics plots, including <code>geom_bar</code>, <code>geom_col</code>, <code>geom_violin</code>, <code>geom_path</code>, <code>geom_text</code>, and <code>geom_boxplot</code>, and convenience functions like <code>labs</code>, <code>lims</code>, themes, saving plots, facetting, and more. I tried to follow SemVer as best as I could and bumped by version number dutifully up to 0.3.2. Collaborators started to show up, adding a logo for the package and some documentation. Things were going quite well, then I hit the first bump in the road in the form of a questionable <code>eval&#40;&#41;</code> call.</p>
<h2 id="the_first_mistake_-_macros"><a href="#the_first_mistake_-_macros" class="header-anchor">The First Mistake - Macros</a></h2>
<p>Julia has a powerful but slightly unwieldy macro system. As far as I can tell, people use it for two very different reasons instead of normal functions.</p>
<ul>
<li><p>The intended reason, which is to write code that you want to evaluate at compile time rather than run time.</p>
</li>
<li><p>To be sneaky and write non-standard code that nonetheless runs in julia.</p>
</li>
</ul>
<p>Tidier.jl, and more specifically TidierData.jl, uses macros mostly for reason 2, and reason 1 is - if anything - a downside. I had written the whole package to use macros to be consistent with how the rest of the Tidier system was shaping up. This resulted in having this block of code inside the function that builds geoms:</p>
<pre><code class="julia hljs"><span class="hljs-comment"># if data is specified, call a questionable eval to grab it as a layer</span>
<span class="hljs-keyword">if</span> haskey(args_dict, <span class="hljs-string">&quot;data&quot;</span>)
  <span class="hljs-comment"># if the code is running in a Pluto.jl notebook</span>
  <span class="hljs-keyword">if</span> !isnothing(match(<span class="hljs-string">r&quot;#==#&quot;</span>, <span class="hljs-meta">@__FILE__</span>))
    plot_data = AlgebraOfGraphics.data(eval(args_dict[<span class="hljs-string">&quot;data&quot;</span>]))
  <span class="hljs-keyword">else</span>
    plot_data = AlgebraOfGraphics.data(Base.eval(Main, args_dict[<span class="hljs-string">&quot;data&quot;</span>]))
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">else</span>
  plot_data = mapping()
<span class="hljs-keyword">end</span></code></pre>
<p>Ew. As I looked upon the monstrosity I had written, I had a realization. I didn&#39;t actually need macros for anything except the <code>aes</code> call. See, TidierData needs macros so that people can write things like:</p>
<pre><code class="julia hljs"><span class="hljs-meta">@mutate</span>(data, A = B * <span class="hljs-number">2</span>)</code></pre>
<p>Where A and B are columns in data, <em>not objects in the global environment as julia would normally interpret them</em>. I needed macros for things like:</p>
<pre><code class="julia hljs"><span class="hljs-meta">@geom_point</span>(data, aes(x = x_col, y = y_col))</code></pre>
<p>But in that call, <code>data</code> really ideally would just be the data - hence the questionable <code>eval</code> code above. Thus began the first full refactor of TidierPlots, and version 0.4.0 completely broke all previous code but switching out macros for function equivalents.</p>
<h2 id="the_second_mistake_-_too_many_layers"><a href="#the_second_mistake_-_too_many_layers" class="header-anchor">The Second Mistake - Too many layers</a></h2>
<p>Just as I finished rewriting the entire package, I realized that I needed to rewrite it again. TidierPlots was originally set up like this:</p>

<figure>
<pre>
┌─────────────┐         ┌───────────────────┐         ┌───────────┐
│ TidierPlots │ ──────► │ AlgebraOfGraphics │ ──────► │   Makie   │
└─────────────┘         └───────────────────┘         └───────────┘
</pre>
</figure>

<p>But that meant that TidierPlots could only support things that AlegebraOfGraphics supports, and - at the time - that wasn&#39;t too long of a list. For example, one thing that it just couldn&#39;t seem to do was make a horizontal bar chart. I set out to strip away the AoG middleman, and version 0.5.0 was born. Thankfully, most of the code that had been written up until that point was focused on building the objects, so it was mostly a matter of swapping out the interpretation part from AoG to Makie&#39;s shiny new SpecApi.</p>
<hr />
<div class="page-foot">
    <a href="https://opensource.org/license/mit">MIT License</a> Randy Boyes.  Website built with
    <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the
    <a href="https://julialang.org">Julia programming language</a>. Design
    inspired by
    <a href="https://owickstrom.github.io/the-monospace-web/"
        >The Monospace Web</a
    >. Code for this website is available on
    <a href="https://github.com/rdboyes/randy-pub">Github</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>
    hljs.highlightAll();
    hljs.configure({ tabReplace: "    " });
</script>

    
  </body>
</html>
