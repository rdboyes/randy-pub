<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
         
        <link rel="stylesheet" href="/libs/highlight/styles/github.min.css">
 
        <link rel="stylesheet" href="/css/reset.css" />
        <link rel="stylesheet" href="/css/normalize.css" />
        <link rel="stylesheet" href="/css/basic.css" />
        <link rel="icon" href="/assets/favicon.png" />
        
        <title>You wouldn't pirate a type (part 2)</title>
        
    </head>
    <body>
        <table class="header">
    <tr>
        <td colspan="2" rowspan="3" scope="header" class="width-min">
            <h1 class="title">randy.pub</h1>
            <span class="subtitle">Personal homepage</span>
        </td>
        <td scope="header" class="width-min">Author</td>
        <td scope="header" class="width-auto">Randy Boyes</td>
    </tr>
    <tr>
        <td scope="header" class="width-min">Updated</td>
        <td scope="header" class="width-auto">
            <time> November 09, 2025</time>
        </td>
    </tr>
    <tr>
        <td scope="header" class="width-min">Nav</td>
        <td scope="header" class="width-auto">
            <a href="/">Home</a>
            <a href="/pubs/">Publications</a>
            <a href="/resume/">Resume</a>
            <a href="/posts/">Posts</a>
        </td>
    </tr>
</table>
<label class="debug-toggle-label"
    ><input type="checkbox" class="debug-toggle" /> Debug mode</label
>


        <!-- Content appended here -->
    </body>
    <div class="debug-grid"></div>
    <script>
        function gridCellDimensions() {
            const element = document.createElement("div");
            element.style.position = "fixed";
            element.style.height = "var(--line-height)";
            element.style.width = "1ch";
            document.body.appendChild(element);
            const rect = element.getBoundingClientRect();
            document.body.removeChild(element);
            return { width: rect.width, height: rect.height };
        }

        // Add padding to each media to maintain grid.
        function adjustMediaPadding() {
            const cell = gridCellDimensions();

            function setHeightFromRatio(media, ratio) {
                const rect = media.getBoundingClientRect();
                const realHeight = rect.width / ratio;
                const diff = cell.height - (realHeight % cell.height);
                media.style.setProperty("padding-bottom", `${diff}px`);
            }

            function setFallbackHeight(media) {
                const rect = media.getBoundingClientRect();
                const height =
                    Math.round(rect.width / 2 / cell.height) * cell.height;
                media.style.setProperty("height", `${height}px`);
            }

            function onMediaLoaded(media) {
                var width, height;
                switch (media.tagName) {
                    case "IMG":
                        width = media.naturalWidth;
                        height = media.naturalHeight;
                        break;
                    case "VIDEO":
                        width = media.videoWidth;
                        height = media.videoHeight;
                        break;
                }
                if (width > 0 && height > 0) {
                    setHeightFromRatio(media, width / height);
                } else {
                    setFallbackHeight(media);
                }
            }

            const medias = document.querySelectorAll("img, video");
            for (media of medias) {
                switch (media.tagName) {
                    case "IMG":
                        if (media.complete) {
                            onMediaLoaded(media);
                        } else {
                            media.addEventListener("load", () =>
                                onMediaLoaded(media),
                            );
                            media.addEventListener("error", function () {
                                setFallbackHeight(media);
                            });
                        }
                        break;
                    case "VIDEO":
                        switch (media.readyState) {
                            case HTMLMediaElement.HAVE_CURRENT_DATA:
                            case HTMLMediaElement.HAVE_FUTURE_DATA:
                            case HTMLMediaElement.HAVE_ENOUGH_DATA:
                                onMediaLoaded(media);
                                break;
                            default:
                                media.addEventListener("loadeddata", () =>
                                    onMediaLoaded(media),
                                );
                                media.addEventListener("error", function () {
                                    setFallbackHeight(media);
                                });
                                break;
                        }
                        break;
                }
            }
        }

        adjustMediaPadding();
        window.addEventListener("load", adjustMediaPadding);
        window.addEventListener("resize", adjustMediaPadding);

        function checkOffsets() {
            const ignoredTagNames = new Set([
                "THEAD",
                "TBODY",
                "TFOOT",
                "TR",
                "TD",
                "TH",
            ]);
            const cell = gridCellDimensions();
            const elements = document.querySelectorAll(
                "body :not(.debug-grid, .debug-toggle)",
            );
            for (const element of elements) {
                if (ignoredTagNames.has(element.tagName)) {
                    continue;
                }
                const rect = element.getBoundingClientRect();
                if (rect.width === 0 && rect.height === 0) {
                    continue;
                }
                const top = rect.top + window.scrollY;
                const left = rect.left + window.scrollX;
                const offset = top % (cell.height / 2);
                if (offset > 0) {
                    element.classList.add("off-grid");
                    console.error(
                        "Incorrect vertical offset for",
                        element,
                        "with remainder",
                        top % cell.height,
                        "when expecting divisible by",
                        cell.height / 2,
                    );
                } else {
                    element.classList.remove("off-grid");
                }
            }
        }

        const debugToggle = document.querySelector(".debug-toggle");
        function onDebugToggle() {
            document.body.classList.toggle("debug", debugToggle.checked);
        }
        debugToggle.addEventListener("change", onDebugToggle);
        onDebugToggle();
    </script>
</html>
<div class="franklin-content"><h2 id="a_more_complete_slice"><a href="#a_more_complete_slice" class="header-anchor">A more complete <code>slice</code></a></h2>
<p><a href="/posts/piracy/">Part 1</a> looked at some basic half-implementations of tidyverse functions, but can we actually get a full implementation of at least one function? <code>slice</code> seems like the easiest, so lets try. Tidyverse <code>slice</code> has the following options:</p>
<ul>
<li><p>slice variants: <code>slice_head</code>, <code>slice_tail</code>, <code>slice_sample</code>, <code>slice_min</code>, and <code>slice_max</code></p>
</li>
<li><p>selection: should support vector-like objects that contain integers as well as ranges, provided they are all positive &#40;to keep&#41; or all negative &#40;to drop&#41;</p>
</li>
<li><p>by: optionally group the dataframe for the duration of this operation only</p>
</li>
<li><p>preserve: should the original grouping, if present, be preserved? &#40;Bool&#41;</p>
</li>
<li><p>n/prop: the number or proportion of rows to keep</p>
</li>
<li><p>order_by: sort the df by this variable prior to slicing if provided</p>
</li>
<li><p>na&#95;rm: should na values of the order&#95;by variable be removed? &#40;Bool&#41;</p>
</li>
<li><p>weight_by: sampling weights</p>
</li>
<li><p>replace: should sampling be with &#40;true&#41; or without &#40;false, the default&#41; replacement</p>
</li>
</ul>
<p>Set up as in the last post:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> DataFrames

<span class="hljs-keyword">struct</span> TidyExpr
    f::<span class="hljs-built_in">Function</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">import</span> Base.|&gt;
Base.:(|&gt;)(x::TidyExpr, y::TidyExpr) = TidyExpr(x.f ∘ y.f)
Base.:(|&gt;)(x::DataFrames.DataFrame, y::TidyExpr) = y.f(x)</code></pre>
<p>We&#39;ll need to expand the slice function to take kwargs and do things with the provided values. Slurped kwargs in julia are represented as Pairs, which can be easily turned into a Dict:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> example(args...; kwargs...)
  println(args)
  println(<span class="hljs-string">&quot;Keyword args:&quot;</span>)
  println(<span class="hljs-built_in">Dict</span>(kwargs))
<span class="hljs-keyword">end</span>

example(<span class="hljs-number">1</span>:<span class="hljs-number">10</span>, by = :a, order_by = :b, na_rm = <span class="hljs-literal">true</span>)</code></pre>
<pre><code class="plaintext hljs">(1:10,)
Keyword args:
Dict{Symbol, Any}(:order_by =&gt; :b, :by =&gt; :a, :na_rm =&gt; true)
</code></pre>
<p>As a first pass, lets set up a loop over a couple of supported kwargs with basic implementations of their functionality.</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> slice(args...; kwargs...)
  f = identity
  <span class="hljs-keyword">for</span> (k, v) <span class="hljs-keyword">in</span> <span class="hljs-built_in">Dict</span>(kwargs)
    <span class="hljs-keyword">if</span> k == :by
      f = f ∘ (x -&gt; groupby(x, v))
    <span class="hljs-keyword">elseif</span> k == :order_by
      f = f ∘ (x -&gt; sort(x, v))
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-keyword">return</span> TidyExpr(x -&gt; f(x) <span class="hljs-keyword">isa</span> GroupedDataFrame ?
    combine(y -&gt; getindex(y, args[<span class="hljs-number">1</span>], :), f(x)) :
    f(x)[args[<span class="hljs-number">1</span>], :])
<span class="hljs-keyword">end</span>

DataFrame(a = <span class="hljs-number">1</span>:<span class="hljs-number">6</span>, b = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]) |&gt; slice(<span class="hljs-number">1</span>, by = :b)</code></pre>
<pre><code class="plaintext hljs">2×2 DataFrame
 Row │ b      a
     │ Int64  Int64
─────┼──────────────
   1 │     1      1
   2 │     2      4</code></pre>
<pre><code class="julia hljs">DataFrame(a = <span class="hljs-number">1</span>:<span class="hljs-number">6</span>, b = <span class="hljs-number">6</span>:-<span class="hljs-number">1</span>:<span class="hljs-number">1</span>) |&gt; slice(<span class="hljs-number">1</span>, order_by = :b)</code></pre>
<pre><code class="plaintext hljs">DataFrameRow
 Row │ a      b
     │ Int64  Int64
─────┼──────────────
   1 │     6      1</code></pre>
<p>The structure of the function works, we just need to add the rest of the arguments:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> slice(args...; kwargs...)
  f = identity
  selection = args[<span class="hljs-number">1</span>]
  <span class="hljs-keyword">if</span> any(selection .&lt; <span class="hljs-number">0</span>)
    selection = setdiff(setdiff)
  <span class="hljs-keyword">end</span>
  dkw = <span class="hljs-built_in">Dict</span>(kwargs)
  <span class="hljs-keyword">for</span> (k, v) <span class="hljs-keyword">in</span> dkw
    <span class="hljs-keyword">if</span> k == :n
      selection = <span class="hljs-number">1</span>:v
    <span class="hljs-keyword">elseif</span> k == :prop
      f = f ∘ (x -&gt; x[<span class="hljs-number">1</span>:floor(nrow(x) * prop), :])
    <span class="hljs-keyword">elseif</span> k == :by
      f = f ∘ (x -&gt; groupby(x, v))
    <span class="hljs-keyword">elseif</span> k == :order_by
      f = f ∘ (x -&gt; sort(x, v))
    <span class="hljs-keyword">elseif</span> k == :replace

    <span class="hljs-keyword">elseif</span> k == :weight_by

    <span class="hljs-keyword">elseif</span> k == :na_rm

    <span class="hljs-keyword">elseif</span> k == :preserve

    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-keyword">return</span> TidyExpr(x -&gt; f(x) <span class="hljs-keyword">isa</span> GroupedDataFrame ?
    combine(y -&gt; getindex(y, selection, :), f(x)) :
    f(x)[selection, :])
<span class="hljs-keyword">end</span></code></pre>
<div class="page-foot">
    <a href="https://opensource.org/license/mit">MIT License</a> Randy Boyes.  Website built with
    <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the
    <a href="https://julialang.org">Julia programming language</a>. Design
    inspired by
    <a href="https://owickstrom.github.io/the-monospace-web/"
        >The Monospace Web</a
    >. Code for this website is available on
    <a href="https://github.com/rdboyes/randy-pub">Github</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>
    hljs.highlightAll();
    hljs.configure({ tabReplace: "    " });
</script>

    
  </body>
</html>
